#![warn(missing_docs)]
//! Interface for use in the FFI.
//!
//! This crate contains most of the necessary functions that are exported to the FFI interface.

extern crate num;
extern crate libc;
extern crate graph;
extern crate newtypes;
extern crate rand;
extern crate util;

use std::ptr;
use std::slice;
use std::ops::Mul;

use graph::error::Error;
use num::traits::WrappingSub;
use newtypes::Km;
use newtypes::ToF64;

use graph::dijkstra::Visited;
use graph::iter;
use graph::GraphTrait;

/// Iterator over all connections from a single node, with ID and Data.
#[repr(C)]
pub struct ConnIdVal(iter::ConnIdVal<'static, Edge>);

/// Iterator over all connections from a single node, with only Data.
#[repr(C)]
pub struct IterEdges(iter::IterEdges<'static, Edge>);

/// Iterator over all connections from a single node, with only ID.
#[repr(C)]
pub struct IterConnIds(iter::IterConnIds<'static, Edge>);

/// Iterator over all node IDs in the graph.
#[repr(C)]
pub struct ListIds(iter::ListIds<'static, Node, Edge>);

/// Iterator over a path generated by Dijkstra's algorithm.
#[repr(C)]
pub struct Root(iter::Root<'static>);

fn owned_ptr<T>(t : Option<T>) -> *mut T {
    t.map(|t| {
        Box::into_raw(Box::new(t))
    }).unwrap_or_else(ptr::null_mut)
}

fn borrowed_ptr<T>(t : Option<&T>) -> *const T {
    t.map(|t| t as *const T)
        .unwrap_or_else(ptr::null)
}


/// Modifiers of an edge.
///
/// Every edge (road) has a few properties: whether it is a highway or a footpath,
/// whether it is in a park, or near water, etc.
/// This structure contains all that data in a slightly compressed format.
#[repr(C)]
#[derive(Clone)]
pub struct Modifiers {
    /// Highway modifier, between 1.0 (footpath) and infinity (motorway)
    pub highway : libc::c_double,
    /// Sum of all the ratings, or `rating_count * average_rating`
    pub rating_sum : libc::c_double,
    /// Number of ratings, or `rating_sum / average_rating`
    pub rating_count : libc::size_t,
    /// 1 if the road is near water, else 0
    pub water : libc::size_t,
    /// 1 if the road is in a park, else 0
    pub park : libc::size_t,
}

/// Modifier of the configuration.
///
/// This structure corresponds to the [Modifiers](Modifiers.html) structure.
/// The larger the value, the larger the importance of the corresponding field in the Modifiers struct.
#[repr(C)]
#[derive(Clone)]
#[allow(missing_docs)]
pub struct Modifier_Dot {
    pub highway : libc::c_double,
    pub rating_sum : libc::c_double,
    pub rating_count : libc::c_double,
    pub water : libc::c_double,
    pub park : libc::c_double,
}

impl<'a, 'b> Mul<&'a Modifier_Dot> for &'b Modifiers {
    type Output=f64;
    fn mul(self, other : &'a Modifier_Dot) -> f64 {
        (self.highway*other.highway
        + match self.rating_count {
            0 => 0.0,
            x => self.rating_sum / x as f64
        } * other.rating_sum
        + self.rating_count as f64 * other.rating_count)
        * (1.0 / if self.water == 1 {other.water.exp()} else {1.0})
        * (1.0 / if self.park == 1 {other.park.exp()} else {1.0})
    }
}

impl Mul<Modifier_Dot> for Modifiers {
    type Output=f64;
    fn mul(self, other : Modifier_Dot) -> f64 {
        (&self) * (&other)
    }
}

impl Modifiers {
    /// Add a rating to the edge
    fn update(&mut self, rating : f64) {
        self.rating_count += 1;
        self.rating_sum += rating;
    }
}

/// Representation of a node.
#[repr(C)]
#[derive(Clone)]
pub struct Node {
    /// Identification number. The graph is more efficient if the id's are successive
    /// (as it relies on a Vector map.)
    pub id : libc::size_t,
    /// The identification number in OpenStreetMaps.
    pub mapid : libc::size_t,
    /// Latitude.
    pub lat : libc::c_double,
    /// Longitude
    pub lon : libc::c_double,
    /// Projection of the longitude on a plane.
    pub x : libc::c_double,
    /// Projection of the latitude on a plane.
    pub y : libc::c_double,
}

impl<'a> Into<(Km, Km)> for &'a Node {
    fn into(self) -> (Km, Km) {
        (Km::from_f64(self.x), Km::from_f64(self.y))
    }
}

/// Road struct
///
/// This structure contains the various fields for
#[repr(C)]
#[derive(Clone)]
pub struct Edge {
    /// Identification number of the source node
    pub id : libc::size_t,
    /// Length of the road
    pub distance : libc::c_double,
    /// Road metadata
    pub modifiers : Modifiers,
    /// Poison value. Used in distance metrics.
    pub poison : libc::c_double,
    /// Identification number of the destination node.
    pub to : libc::size_t,
}

impl Edge {
    /// Poisons an edge.
    fn elongate(&self, dist : f64, max : f64) -> Edge {
        let mut edge = self.clone();
        edge.poison = max.powf(1.0 - dist);
        edge
    }
}

/// Representation of a graph
#[repr(C)]
pub struct Graph(graph::Graph<Node, Edge>);

/// Representation of a poisoned graph
#[repr(C)]
pub struct Poison(graph::Poisoned<'static, Node, Edge, graph::Graph<Node, Edge>>);

/// Representation of an edge and its ID, as yielded by a ConnId iterator.
#[repr(C)]
pub struct IdVal {
    /// Identification number of the destination edge
    pub id : libc::size_t,
    /// Edge data
    pub e : *const Edge,
}

use util::comp::Comp;

/// Structure yielded by a Dijkstra's iterator.
#[repr(C)]
pub struct DijkstraNode {
    /// Node identification number
    pub id : libc::size_t,
    /// Distance in reality, measured in km.
    pub size_value : libc::c_double,
    /// Distance as perceived, measured in km.
    pub actual_value : libc::c_double,
}

/// The actual configuration.
///
/// This struct contains, next to the local position, all necessary data in order
/// to generate a route.
#[repr(C)]
#[derive(Clone)]
pub struct Configuration {
    /// Importance of the actual distance travelled.
    pub value_length : libc::c_double,
    /// Modifiers.
    pub value_modifiers : Modifier_Dot,
    /// Maximum distance allowed.
    pub distance_max : libc::c_double,
    /// Minimum distance allowed
    pub distance_min : libc::c_double,
}

/// DijkstraIterator.
#[repr(C)]
pub struct DijkstraIterator(InsideDijkstra);

struct InsideDijkstra(Box<Iterator<Item=(usize, Comp)> + 'static>, Visited);

impl Iterator for DijkstraIterator {
    type Item=DijkstraNode;
    fn next(&mut self) -> Option<Self::Item> {
        (self.0).0.next().map(|(n, comp)| DijkstraNode {
            id : n,
            size_value : comp.size().to_f64(),
            actual_value : comp.actual().to_f64()
            })
    }
}

impl DijkstraIterator {
    fn new(i : Box<Iterator<Item=(usize, Comp)> + 'static>, v : Visited) -> DijkstraIterator {
        DijkstraIterator(InsideDijkstra(i, v))
    }
}

impl Graph {
    fn new(nodes : &[Node], edges : &[Edge]) -> Result<Graph, Error> {
        Ok(Graph(
            try!(graph::Graph::new(
                nodes.iter().map(|node| (node.id, node.clone())),
                edges.iter().map(|edge| (edge.id, edge.clone(), edge.to))
             ))
        ))
    }

    fn update_rating(&mut self, from : usize, to : usize, rating : f64) -> bool {
        match self.0.get_edge_mut(from, to) {
            Some(ref mut t) => {t.modifiers.update(rating); true},
            _ => false
        }
    }

    fn poison(&'static self, rod : &[usize], max_distance : f64, max_value : f64) -> Poison {
        let iterator = self.0.gen_limited_dijkstra_vec(
                rod,
                |edge| Comp::new(Some(Km::from_f64(edge.distance)), Km::from_f64(edge.distance)),
                move |_, comp| comp.is_finite() && comp.actual() < Km::from_f64(max_distance),
            );
        let mut nodes = Vec::new();
        let mut edges = Vec::new();
        for (id, distance) in iterator {
            nodes.push((id, self.0.get(id).unwrap()));
            for (to, edge) in self.0.get_conn_idval(id).unwrap() {
                edges.push((id, edge.elongate(distance.actual().to_f64()/max_distance, max_value), to));
            }
        }
        Poison(graph::Poisoned::new(&nodes, &edges, &self.0).unwrap())
    }
}

fn generate_route<G : GraphTrait<V=Node, E=Edge>>(graph : &'static G, start_node : usize, config : Configuration) -> DijkstraIterator {
    let (vm, vl, dh, _) = (
        config.value_modifiers,
        config.value_length,
        Km::from_f64(config.distance_max),
        Km::from_f64(config.distance_min),
    );
    let iterator = graph.gen_limited_dijkstra_vec(
        &[start_node] as &[usize],
        move |edge| Comp::new(Km::from_f64_checked((
                &edge.modifiers * &vm
                 + vl) * edge.distance
                 * edge.poison),
            Km::from_f64(edge.distance)
        ),
        move |_, comp| {
            comp.is_finite()
               && comp.actual()
                //+ distance(graph.get(id).unwrap(), graph.get(start_node).unwrap())
                //+ graph.get_measure(id)
                < dh
            }
    );
    let visited = iterator.visited();
    DijkstraIterator::new(Box::new(iterator), visited)
}

// Welcome to Rust ffi, the only thing that is even more unsafe than raw C.
// Ye who enters here: abandon all faith.

/// Create a new graph.
#[no_mangle]
pub unsafe extern "C" fn graph_new(nodes : *const Node,
                                 nodelen : libc::size_t,
                                 edges : *const Edge,
                                 edgelen : libc::size_t) -> *mut Graph
{
    let nodes = slice::from_raw_parts(nodes, nodelen);
    let edges = slice::from_raw_parts(edges, edgelen);
    return owned_ptr(Graph::new(nodes, edges).ok());
}

/// Delete the graph, freeing its memory.
#[no_mangle]
pub unsafe extern "C" fn graph_delete(graph : *mut Graph) {
    Box::from_raw(graph);
}

/// Retrieve a node from the graph
#[no_mangle]
pub unsafe extern "C" fn graph_get(graph : *const Graph, index : libc::size_t) -> *const Node
{
    borrowed_ptr((&*graph).0.get(index))

}

/// Check if the graph contains a node with the given index
#[no_mangle]
pub unsafe extern "C" fn graph_contains(graph : *const Graph, index : libc::size_t) -> bool
{
    (&*graph).0.contains(index)
}


/// Retrieve an iterator over all edges and connected ids.
#[no_mangle]
pub unsafe extern "C" fn graph_conn_idval_new(graph : *const Graph, index : libc::size_t) -> *mut ConnIdVal
{
    owned_ptr((&*graph).0.get_conn_idval(index).map(ConnIdVal))
}

/// Advance the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_conn_idval_next(conn_idval : *mut ConnIdVal) -> IdVal {
    (&mut *conn_idval).0.next()
        .map(|(id, e)| IdVal{id : id, e : e})
        .unwrap_or(IdVal{id : 0, e : ptr::null()})
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_conn_idval_delete(conn_idval : *mut ConnIdVal) {
    Box::from_raw(conn_idval);
}

/// Retrieve an iterator over all edges
#[no_mangle]
pub unsafe extern "C" fn graph_edges_new(graph : *const Graph, index : libc::size_t) -> *mut IterEdges {
    owned_ptr((&*graph).0.get_edges(index).map(IterEdges))
}

/// Advance the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_edges_next(edges : *mut IterEdges) -> *const Edge {
    borrowed_ptr((&mut *edges).0.next())
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_edges_delete(edges : *mut IterEdges) {
    Box::from_raw(edges);
}

/// Retrieve an iterator over all connection ids
#[no_mangle]
pub unsafe extern "C" fn graph_connids_new(graph : *const Graph, index : libc::size_t) -> *mut IterConnIds {
    owned_ptr((&*graph).0.get_connids(index).map(IterConnIds))
}

/// Advance the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_connids_next(connids : *mut IterConnIds) -> libc::size_t {
    (&mut *connids).0.next().unwrap_or(0.wrapping_sub(&1))
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_connids_delete(connids : *mut IterConnIds)  {
    Box::from_raw(connids);
}

/// Retrieve an iterator over all node ids in the graph
#[no_mangle]
pub unsafe extern "C" fn graph_listids_new(graph : *const Graph) -> *mut ListIds {
    owned_ptr(Some((&*graph).0.list_ids()).map(ListIds))
}

/// Advance the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_listids_next(listids : *mut ListIds) -> libc::size_t {
    (&mut *listids).0.next().unwrap_or(0.wrapping_sub(&1))
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_listids_delete(listids : *mut ListIds)  {
    Box::from_raw(listids);
}

/// Retrieve a new poisoned graph.
///
/// A poisoned graph is a graph where some perceived lengths have been increased in order
/// to avoid the route generator to include these edges.
#[no_mangle]
pub unsafe extern "C" fn graph_poison(graph : *const Graph, rod : *const libc::size_t, length : libc::size_t, max_distance : libc::c_double, max_value : libc::c_double) -> *mut Poison
{
    owned_ptr(Some((&*graph).poison(slice::from_raw_parts(rod, length), max_distance, max_value)))
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_poison_delete(poison : *mut Poison) {
    Box::from_raw(poison);
}

/// Generate a collection of shortest paths from a starting point
#[no_mangle]
pub unsafe extern "C" fn graph_graph_generate(graph : *const Graph, start_node : libc::size_t, config : *const Configuration) -> *mut DijkstraIterator
{
    Box::into_raw(Box::new(generate_route(&(&*graph).0, start_node, (&*config).clone())))
}

/// Generate a collection of shortest paths from a starting point
#[no_mangle]
pub unsafe extern "C" fn graph_poison_generate(poison : *const Poison, start_node : libc::size_t, config : *const Configuration) -> *mut DijkstraIterator
{
    Box::into_raw(Box::new(generate_route(&(&*poison).0, start_node, (&*config).clone())))
}

/// Advance the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_dijkstra_next(dijkstra : *mut DijkstraIterator) -> DijkstraNode {
    (&mut *dijkstra).next().unwrap_or(DijkstraNode {
        id : 0.wrapping_sub(&1),
        size_value : 0.0,
        actual_value : 0.0,
    })
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_dijkstra_delete(dijkstra : *mut DijkstraIterator) {
    Box::from_raw(dijkstra);
}

/// Root the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_dijkstra_root(dijkstra : *mut DijkstraIterator, index : libc::size_t) -> *mut Root {
    let root = Root (iter::Root::new(((&*dijkstra).0).1.borrow(), index));
    owned_ptr(Some(root))
}

/// Advance the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_root_next(root : *mut Root) -> libc::size_t {
    (&mut *root).0.next().unwrap_or(0.wrapping_sub(&1))
}

/// Delete the iterator
#[no_mangle]
pub unsafe extern "C" fn graph_root_delete(root : *mut Root) {
    Box::from_raw(root);
}

/// Filter the dijkstraiterator, so that it only returns nodes included in the node list.
/// Rooting keeps working.
#[no_mangle]
pub unsafe extern "C" fn graph_dijkstra_filter(dijkstra : *mut DijkstraIterator, rod : *const libc::size_t, size : libc::size_t) -> *mut DijkstraIterator {
    use std::collections::BTreeSet;
    use std::iter::FromIterator;

    let sl = slice::from_raw_parts(rod, size);
    let set = BTreeSet::from_iter(sl.iter().cloned());
    let inside = Box::from_raw(dijkstra).0;
    let res = InsideDijkstra(Box::new(inside.0.filter(move |&(u, _)| set.contains(&u))), inside.1);
    owned_ptr(Some(DijkstraIterator(res)))
}

/// Pick a random element from the dijkstraiterator that is at a decent distance.
/// Rooting keeps working.
#[no_mangle]
pub unsafe extern "C" fn graph_dijkstra_choose(dijkstra : *mut DijkstraIterator, config : *const Configuration) -> *mut DijkstraIterator {
    use util::selectors::Selector;
    let inside = Box::from_raw(dijkstra).0;
    let conf : &Configuration = &*config;
    let min_dist = Km::from_f64(conf.distance_min);
    let res = InsideDijkstra(Box::new(Selector::from_iterator(
        inside.0.filter(|&(_, ref comp)| comp.actual() > min_dist * 0.5),
        |&(_, ref comp)| comp.actual().to_f64() / comp.size().to_f64().sqrt(),
        rand::thread_rng()
    ).decompose().into_iter()), inside.1);
    owned_ptr(Some(DijkstraIterator(res)))
}

/// Update the rating of the road in the graph
#[no_mangle]
pub unsafe extern "C" fn graph_update_rating(graph : *mut Graph, from : libc::size_t, to : libc::size_t, rating : libc::c_double) -> libc::c_int {
    if (&mut *graph).update_rating(from, to, rating) {
        1
    }
    else {
        0
    }
}
